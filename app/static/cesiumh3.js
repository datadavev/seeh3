const GLOBAL_RECT = "-180,90,180,-90";
const COLORS = [
    Cesium.Color.fromCssColorString('#8a00e2'),
    Cesium.Color.fromCssColorString('#9428e3'),
    Cesium.Color.fromCssColorString('#9d3de4'),
    Cesium.Color.fromCssColorString('#a54fe4'),
    Cesium.Color.fromCssColorString('#ae5fe4'),
    Cesium.Color.fromCssColorString('#b56ee4'),
    Cesium.Color.fromCssColorString('#bd7ce4'),
    Cesium.Color.fromCssColorString('#c48ae4'),
    Cesium.Color.fromCssColorString('#cb99e3'),
    Cesium.Color.fromCssColorString('#d2a6e2'),
    Cesium.Color.fromCssColorString('#d8b4e0'),
    Cesium.Color.fromCssColorString('#dec2de'),
    Cesium.Color.fromCssColorString('#e5d0dc'),
    Cesium.Color.fromCssColorString('#ebded8'),
    Cesium.Color.fromCssColorString('#f2ebd3'),
    Cesium.Color.fromCssColorString('#fbf9c8')
]


function d(rd) {
    return Cesium.Math.toDegrees(rd);
}

function r2str(r) {
    let x0 = d(r.west);
    let x1 = d(r.east);
    let y0 = d(r.south);
    let y1 = d(r.north);
    return `${x0},${y0},${x1},${y1}`;
}


function v2color(v) {
    /* Generated by https://gka.github.io/palettes/#/16|s|8a00e2,e5e5e5,fbf9c8|ffffe0,ff005e,93003a|1|1

    v is a floating point value ranging from 0 to 1.0.
    */
    let idx = Math.round(15.0 * v);
    if (idx < 0) {
        idx = 0;
    } else if (idx > 15) {
        idx = 15;
    }
    return COLORS[idx].withAlpha(0.5);
}


class H3Grid {
    constructor() {
        this._service = "http://localhost:8000/counts/?";
        this.rect_str = "";
        this.data = null;
    }

    async load(rstr) {
        if (rstr === this.rect_str) {
            if (this.data !== null) {
                return this.data;
            }
        }
        this.rect_str = rstr;
        this.loading = true;
        let url = this._service;
        if (this.rect_str !== GLOBAL_RECT) {
            url = url + "&bb=" + this.rect_str;
        } else {
            url = url + "&resolution=3";
        }
        const options = {
            clampToGround: true,
            disableDepthTestDistance: Number.POSITIVE_INFINITY
        };
        try {
            console.log(`Loading ${url} ...`);
            const ds = await Cesium.GeoJsonDataSource.load(url, options);
            console.log("Loaded.");
            ds.name = this.rect_str;
            this.data = ds;
            let entities = ds.entities.values;
            for (var i = 0; i < entities.length; i++) {
                let entity = entities[i];
                try {
                    let ln = parseFloat(entity.properties.ln);
                    //let color = Cesium.Color.fromHsl(0.6 - ln * 0.5, 1.0, 0.5, 0.7);
                    //entity.polygon.material = Cesium.Color.YELLOW.withAlpha(ln);
                    entity.polygon.material = v2color(ln);
                    //entity.polygon.extrudedHeight = parseFloat(entity.properties.n);
                    //entity.polygon.extrudedHeightReference = Cesium.HeightReference.RELATIVE_TO_GROUND
                    //entity.polygon.height = 100;
                } catch (err) {
                    console.log(err);
                    entity.polygon.material = Cesium.Color.RED.withAlpha(0.5);
                }
//entity.polygon.extrudedHeight = 20;
            }
        } catch (err) {
            console.log(err);
        }
        return this.data;
    }

    get name() {
        if (this.data !== null) {
            return this.data.name;
        }
        return null;
    }
}

class H3GridManager {
    constructor() {
        console.log("gm constructor");
        this.global_grid = new H3Grid();
        this.current_grid = this.global_grid;
        this.current_rect = GLOBAL_RECT;
    }

    update(cview, rect) {
        const rstr = r2str(rect);
        console.log(`update: ${rstr}`);
        const existing = cview.dataSources.getByName(rstr);
        if (existing.length > 0) {
            console.log(`Grid ${rstr} already in collection`);
            return;
        }
        let g = this.global_grid;
        if (rect !== GLOBAL_RECT) {
            g = new H3Grid();
        }
        const _this = this;
        g.load(rstr).then((ds) => {
            // delete existing grid
            try {
                cview.dataSources.remove(_this.current_grid.data, true);
                cview.dataSources.add(ds);
                _this.current_grid = g;
                _this.current_rect = rect;
            } catch (err) {
                console.log(err);
            }
        });
    }
}
